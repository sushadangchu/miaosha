# java高并发秒杀项目
#### 本项目基于慕课网java秒杀课程，当完成课程的全部内容后，会在课程内容的基础上扩展
##### 第一次提交，完成课程的第一章
- 配置mysql
- 配置redis，并且增加redis的基础操作，在redis包下的redisService.java中,get,set,exists,incr,decr操作，并且配置了jedisPool连接池
- 添加了prefix接口，避免redis key重复
- 添加了基础类result，统一封装成功数据和错误信息
- 其他内容均为测试项目框架是否配置成功
#### 第二次提交，完成课程第二章和第三章
- 配置实现了全局的异常处理
- 配置实现了全局的参数解析和参数校验
- 实现了秒杀核心功能，包括数据库商品表，订单表，秒杀商品表，秒杀订单表，以及对应的前端页面
- 实现了登陆功能以及分布式session，将session信息保存在redis中，每次从redis中取出并更新cookie保存时间，数据库表为秒杀用户表
- 登陆功能使用了2次的md5，客户端一次，服务端一次
#### 第三次提交，完成课程第四章
- 主要对商品列表和秒杀功能进行了压力测试
- 将项目通过mvn clean package命令打包并且发送到linux服务器运行
- 在服务器上安装jmeter对miaosha.jar项目的两个功能进行压力测试
- 压力测试吞吐量结果已经分别写到商品列表和秒杀功能的注释中
- 压力测试结果表明，目前存在的bug为多个用户同时秒杀会造成秒杀商品库存为负数，后续尝试修复
- 目前吞吐量还不够，测试时系统负载都集中在mysql数据库
- 后续会增加各种缓存和前端页面的静态化，来减缓数据库的压力
#### 第四次提交，完成课程第五章
- 将商品列表页加入redis缓存，请求该页面时，如果redis里有，就直接返回，没有，则手动渲染一个返回，并且加入到redis中，设置过期时间为60s
- 页面缓存感觉有些不太好，因为如果60s修改了动态数据，访问者并不能看到。
- 加入对象缓存，用户，订单，商品，查询时先去redis，没有则去db，且放入redis。
- 对象缓存删除时，应该先删除数据库，再删除redis，因为如果先删除redis后，其他访问者正好查询改数据，又会将旧的数据放入redis，导致数据不一致。
- 将商品页面，详情页，秒杀页面，订单页面静态化，访问时通过页面js ajax请求动态数据，并且加入客户端缓存，减轻服务器压力。
- 秒杀时会减少库存，通过sql语句中加入库存大于0时才减少，如果sql语句未执行，则返回秒杀结束，来解决超卖问题，同时库存又不会减少为负数。
- 目前存在疑惑，如果事务必须产生异常才会回滚的话，如果更新失败，返回0行受影响，并不会回滚，那么课程中是如何解决的？我是通过加入受影响行数判断来返回异常，和课程中方法不同。

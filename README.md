# java高并发秒杀项目
#### 本项目基于慕课网java秒杀课程，当完成课程的全部内容后，会在课程内容的基础上扩展
##### 第一次提交，完成课程的第一章
- 配置mysql
- 配置redis，并且增加redis的基础操作，在redis包下的redisService.java中,get,set,exists,incr,decr操作，并且配置了jedisPool连接池
- 添加了prefix接口，避免redis key重复
- 添加了基础类result，统一封装成功数据和错误信息
- 其他内容均为测试项目框架是否配置成功
#### 第二次提交，完成课程第二章和第三章
- 配置实现了全局的异常处理
- 配置实现了全局的参数解析和参数校验
- 实现了秒杀核心功能，包括数据库商品表，订单表，秒杀商品表，秒杀订单表，以及对应的前端页面
- 实现了登陆功能以及分布式session，将session信息保存在redis中，每次从redis中取出并更新cookie保存时间，数据库表为秒杀用户表
- 登陆功能使用了2次的md5，客户端一次，服务端一次
#### 第三次提交，完成课程第四章
- 主要对商品列表和秒杀功能进行了压力测试
- 将项目通过mvn clean package命令打包并且发送到linux服务器运行
- 在服务器上安装jmeter对miaosha.jar项目的两个功能进行压力测试
- 压力测试吞吐量结果已经分别写到商品列表和秒杀功能的注释中
- 压力测试结果表明，目前存在的bug为多个用户同时秒杀会造成秒杀商品库存为负数，后续尝试修复
- 目前吞吐量还不够，测试时系统负载都集中在mysql数据库
- 后续会增加各种缓存和前端页面的静态化，来减缓数据库的压力
#### 第四次提交，完成课程第五章
- 将商品列表页加入redis缓存，请求该页面时，如果redis里有，就直接返回，没有，则手动渲染一个返回，并且加入到redis中，设置过期时间为60s
- 页面缓存感觉有些不太好，因为如果60s修改了动态数据，访问者并不能看到。
- 加入对象缓存，用户，订单，商品，查询时先去redis，没有则去db，且放入redis。
- 对象缓存删除时，应该先删除数据库，再删除redis，因为如果先删除redis后，其他访问者正好查询改数据，又会将旧的数据放入redis，导致数据不一致。
- 将商品页面，详情页，秒杀页面，订单页面静态化，访问时通过页面js ajax请求动态数据，并且加入客户端缓存，减轻服务器压力。
- 秒杀时会减少库存，通过sql语句中加入库存大于0时才减少，如果sql语句未执行，则返回秒杀结束，来解决超卖问题，同时库存又不会减少为负数。
- 目前存在疑惑，如果事务必须产生异常才会回滚的话，如果更新失败，返回0行受影响，并不会回滚，那么课程中是如何解决的？我是通过加入受影响行数判断来返回异常，和课程中方法不同。
#### 第五次提交，完成课程第六章
- 加入rabbitmq消息队列，异步下单，减少服务器瞬时压力
- 优化秒杀接口，秒杀时先判断内存标记，如果已经秒杀结束，直接返回，如果没有结束，去redis里预减库存，知道结果小于0，设置内存标记位true，之后进来的请求直接返回。
- 之后，根据用户id和商品id判断是否已经秒杀过了，如果没有，就将用户和商品信息加入消息队列，发送出去，然后返回0，表示排队中，异步下单。
- 消息队列收到消息，首先继续判断数据库库存是否<=0，如果是，直接返回。
- 之后，继续判断是否秒杀过，没有的话执行秒杀操作，减库存，如果库存更新失败，说明库存为0，redis设置秒杀结束标志位，为用户判断秒杀结果提供依据。
- 最后，返回秒杀成功的订单号。
- 客户端同步轮询调用秒杀结果接口，如果返回数据大于0，说明成功，为订单号，可直接跳转到支付界面。
- 如果结果为0，说明仍然在排队中，结果为-1(通过redis里设置的标志位来判断)，说明秒杀结束，返回失败。
- 首先，通过redis和内存标记，大大减轻了访问数据库的线程数量，其次，加入消息队列，即使进入的线程再多，也能一个一个处理，不会造成错误情况，真正做到了高并发，高可用。
- 最终秒杀接口的qps为5200，通过jmeter压力测试，5000个线程0秒启动，循环10次，在本地的4核虚拟机上已经是很好的成绩了。
- miaosha.jar,redis,mysql,rabbitmq都部署在一个服务器中，压力非常大，但是业务逻辑是通用的。